/* eslint-disable no-console */

import path from "node:path";
import { fileURLToPath } from "node:url";
import { execSync } from "child_process";
import { readFileSync, writeFileSync, existsSync, rmSync } from "fs";

const dirname = path.dirname(fileURLToPath(import.meta.url));
const SOURCE_FILE = path.join(dirname, "__generated__", "tokens.json");
const TMP_OUTPUT_FILE = path.join(dirname, "__generated__", "tokens-tmp.json");
const OUTPUT_FILE = path.join(dirname, "__generated__", "tokens.ts");

const traverse = (
  node: unknown,
  nodePath: string[],
  fn: (path: string[], type: string, value: unknown) => void
) => {
  if (typeof node !== "object" || node === null) {
    return;
  }

  const entries = Object.entries(node);

  // TypeScript forces us to use entries to read properties of an unknown object
  const type = entries.find(([key]) => key === "type");
  const value = entries.find(([key]) => key === "value");

  // if there's a `type` and `value` properties, treat it as a tree leaf
  if (type && value && typeof type[1] === "string") {
    fn(nodePath, type[1], value[1]);
    // otherwise, traverse deeper
  } else {
    for (const [key, value] of entries) {
      traverse(value, [...nodePath, key], fn);
    }
  }
};

const toCamelCase = (text: string) =>
  text
    .split(/[^a-z0-9]+/i)
    .map((word) => {
      if (word.length === 0) {
        return "";
      }
      return word[0].toUpperCase() + word.slice(1);
    })
    .join("");

const trimPrefix = (prefix: string, text: string) => {
  if (text.toLocaleLowerCase().startsWith(prefix.toLocaleLowerCase())) {
    return text.slice(prefix.length);
  }
  return text;
};

const deCapitalize = (text: string) => text[0].toLowerCase() + text.slice(1);

const pathToName = (path: string[], type: string) =>
  deCapitalize(trimPrefix(type, toCamelCase(path.join("-"))));

const main = () => {
  execSync(`token-transformer ${SOURCE_FILE} ${TMP_OUTPUT_FILE}`, {
    stdio: "inherit",
  });

  const data = JSON.parse(readFileSync(TMP_OUTPUT_FILE, "utf-8"));

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const byType = new Map<string, Record<string, any>>();

  traverse(data, [], (path, type, value) => {
    const record = byType.get(type) ?? {};
    byType.set(type, record);

    // no need to check for __proto__ (prototype polution)
    // because we know pathToName returns a string without "_"
    record[pathToName(path, type)] = value;
  });

  writeFileSync(
    OUTPUT_FILE,
    "// Generated by transform.ts\n\n" +
      [...byType.entries()]
        .map(
          ([type, values]) =>
            `export const ${type} = ${JSON.stringify(values)} as const`
        )
        .join(";\n\n")
  );

  execSync(`prettier --write ${OUTPUT_FILE}`, { stdio: "inherit" });
};

const cleanup = () => {
  if (existsSync(TMP_OUTPUT_FILE)) {
    rmSync(TMP_OUTPUT_FILE);
  }
};

try {
  main();
} catch (error) {
  try {
    cleanup();
  } catch (cleanupError) {
    console.error("Cleanup failed:", cleanupError);
  }
  throw error;
}
cleanup();
